<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Word Search â€” Fixed Words per Line (Legend)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --cell: 34px;
      --accent: #3b82f6;
      --accent-2: #0ea5e9;
      --good: #22c55e;
      --warn: #f59e0b;
      --bg: #0b1020;
      --panel: #11193a;
      --text: #e9eefc;
      --muted: #9fb2e1;
      --grid-line: #2a3a75;
      --solution: #ffd86b88;
      --select: #9ae6ff66;
      --found: #66ff9a88;
    }
    html, body {
      background: linear-gradient(180deg, #0b1020 0%, #0d1330 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
      margin: 0; height: 100%;
    }
    .wrap { max-width: 1100px; margin: 24px auto; padding: 0 16px 48px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    h1 { font-size: 1.4rem; margin: 0; }
    .card {
      background: linear-gradient(180deg, #10194a 0%, #0e1540 100%);
      border: 1px solid #1b2a65; border-radius: 14px; padding: 16px;
      box-shadow: 0 6px 22px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.04);
    }
    .layout { display: grid; grid-template-columns: 1.15fr .85fr; gap: 16px; }
    @media (max-width: 980px) { .layout { grid-template-columns: 1fr; } }
    .controls { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    textarea, input[type="number"] {
      background: #0d1540; border: 1px solid #1f2f74; color: var(--text);
      border-radius: 10px; padding: 10px 12px; outline: none; min-width: 160px;
    }
    textarea { width: 100%; min-height: 140px; resize: vertical; }
    label { font-size: 0.9rem; color: var(--muted); display: block; margin-bottom: 6px; }
    .btn {
      appearance: none; border: 0; border-radius: 10px; padding: 10px 14px;
      font-weight: 700; color: white; cursor: pointer;
      background: linear-gradient(180deg, var(--accent) 0%, var(--accent-2) 100%);
      box-shadow: 0 8px 24px rgba(59,130,246,.35), inset 0 1px 0 rgba(255,255,255,.2);
      transition: transform .05s ease, filter .15s ease;
    }
    .btn.secondary { background: #162255; color: #cfe1ff; box-shadow: inset 0 1px 0 rgba(255,255,255,.06); }
    .btn:active { transform: translateY(1px); }

    .grid {
      display: grid; gap: 2px; background: var(--grid-line);
      padding: 2px; border-radius: 10px; user-select: none; touch-action: none; width: max-content;
    }
    .cell {
      width: var(--cell); height: var(--cell); display: grid; place-items: center;
      font-weight: 700; letter-spacing: .5px; color: #eaf1ff; background: #0f1842;
      border-radius: 8px; transition: transform .06s ease, background .12s ease, color .12s ease;
    }
    .cell:hover { transform: translateY(-1px); }
    .cell.sel { background: var(--select); color: #07122e; }
    .cell.sol { background: var(--solution); color: #101539; }
    .cell.found { background: var(--found); color: #0b1b1d; }

    .pill {
      display: inline-flex; gap: 8px; align-items: center; padding: 6px 10px; border-radius: 999px;
      background: #0c1540; border: 1px solid #1a2a68; color: #cfe1ff; font-size: 0.9rem;
    }
    .small { font-size: .9rem; color: var(--muted); }
    .ok { color: var(--good); } .warn { color: var(--warn); }
    .status { min-height: 20px; }

    /* Legend with fixed words per line using CSS Grid columns */
    .legend {
      display: grid; gap: 8px 12px; /* row gap / column gap */
      grid-auto-rows: minmax(24px, auto);
    }
    .legend-item {
      display: inline-flex; align-items: center; gap: 8px;
      background: #0c1540; border: 1px solid #1a2a68; padding: 6px 10px; border-radius: 999px;
      min-width: 0; white-space: nowrap;
    }
    .swatch {
      width: 14px; height: 14px; border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.2); box-shadow: inset 0 1px 0 rgba(255,255,255,.15);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Word Search â€” Fixed Words per Line</h1>
      <span class="pill">ðŸ“± Mobile-friendly</span>
    </header>

    <div class="layout">
      <!-- Left: Game -->
      <section class="card">
        <div class="controls" style="margin-bottom:12px">
          <div style="flex:1 1 420px">
            <label for="words">Words (one per line)</label>
            <textarea id="words" placeholder="CAT
PYTHON
ALGORITHM
SEARCH
MATRIX
PUZZLE"></textarea>
          </div>
          <div class="side" style="min-width:240px; display:grid; gap:10px;">
            <div>
              <label for="size">Grid size</label>
              <input id="size" type="number" min="8" max="30" value="12" />
            </div>
            <div>
              <label for="wpr">Words per line (legend)</label>
              <input id="wpr" type="number" min="1" max="6" value="3" />
            </div>
            <div class="controls">
              <button class="btn" id="btn-generate">Generate</button>
              <button class="btn secondary" id="btn-toggle">Show solution</button>
            </div>
            <div class="status small" id="status">Tip: Click/touch and drag to select words.</div>
          </div>
        </div>

        <div id="grid" class="grid" style="grid-template-columns: repeat(12, var(--cell));"></div>
      </section>

      <!-- Right: Legend with fixed words per line -->
      <aside class="card">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
          <div class="pill">ðŸ§© Word list</div>
          <div id="fit-indicator" class="small">â€”</div>
        </div>
        <div id="legend" class="legend"></div>
        <div class="small" style="margin-top:8px">
          Horizontal, vertical, and diagonal (both directions) supported.
        </div>
      </aside>
    </div>
  </div>

  <script>
    /* ========= Generator ========= */
    const DIRECTIONS = [
      [0,1],[1,0],[0,-1],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]
    ];
    const randInt = n => Math.floor(Math.random() * n);

    function tryPlaceWord(grid, word, r0, c0, dr, dc) {
      const n = grid.length;
      const re = r0 + dr * (word.length - 1);
      const ce = c0 + dc * (word.length - 1);
      if (re < 0 || re >= n || ce < 0 || ce >= n) return null;
      const coords = [];
      for (let i=0;i<word.length;i++){
        const r = r0 + dr*i, c = c0 + dc*i;
        const cell = grid[r][c];
        if (cell && cell !== word[i]) return null;
        coords.push([r,c]);
      }
      coords.forEach(([r,c],i)=> grid[r][c] = word[i]);
      return coords;
    }
    function placeWord(grid, word) {
      const n = grid.length;
      for (let t=0;t<250;t++){
        const r = randInt(n), c = randInt(n);
        const [dr,dc] = DIRECTIONS[randInt(DIRECTIONS.length)];
        const placed = tryPlaceWord(grid, word, r, c, dr, dc);
        if (placed) return placed;
      }
      return null;
    }
    function generateWordSearchJS(words, size=12){
      // normalize to ONE WORD PER LINE strictly
      const normalized = [];
      const seen = new Set();
      for (const wRaw of words){
        // split by non-letters to be strict; keep Aâ€“Z only
        const parts = wRaw.toUpperCase().split(/[^A-Z]+/).filter(Boolean);
        for (const part of parts){
          if (!seen.has(part)){ seen.add(part); normalized.push(part); }
        }
      }
      const sorted = [...normalized].sort((a,b)=> b.length - a.length);
      const grid = Array.from({length:size},()=> Array(size).fill(""));
      const placements = {};
      const unplaced = [];
      for (const w of sorted){
        let coords = placeWord(grid, w);
        if (!coords){
          const rev = w.split("").reverse().join("");
          coords = placeWord(grid, rev);
        }
        if (coords) placements[w] = coords;
        else unplaced.push(w);
      }
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      for (let r=0;r<size;r++){
        for (let c=0;c<size;c++){
          if (!grid[r][c]) grid[r][c] = letters[randInt(letters.length)];
        }
      }
      return {
        grid: grid.map(row=>row.join("")),
        placements, unplaced, words: normalized, size
      };
    }

    /* ========= UI & State ========= */
    const gridEl = document.getElementById("grid");
    const legendEl = document.getElementById("legend");
    const fitIndicator = document.getElementById("fit-indicator");
    const statusEl = document.getElementById("status");
    const toggleBtn = document.getElementById("btn-toggle");
    const wprInput = document.getElementById("wpr");

    const palette = i => ([
      "#ffd86b88","#6be6ff88","#a0ff6b88","#ff6bd688","#6b8bff88",
      "#ff9a6b88","#6bffc888","#ff6b8b88","#b06bff88","#6bff9a88"
    ][i % 10]);

    let current = {
      grid: [], placements: {}, unplaced: [], words: [],
      size: 12, solutionShown: false, foundWords: new Set()
    };

    function readWordsStrict() {
      // Enforce ONE WORD PER LINE. If user pasted commas/spaces, we fix it.
      const raw = document.getElementById("words").value;
      const lines = raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      // Also normalize: split non-letters to keep the rule strict
      const fixed = [];
      for (const line of lines){
        const parts = line.toUpperCase().split(/[^A-Z]+/).filter(Boolean);
        fixed.push(...parts);
      }
      // write back as single word per line (for clarity)
      document.getElementById("words").value = fixed.join("\n");
      return fixed;
    }

    function renderGrid(grid, size){
      gridEl.style.gridTemplateColumns = `repeat(${size}, var(--cell))`;
      gridEl.innerHTML = "";
      for (let r=0;r<size;r++){
        for (let c=0;c<size;c++){
          const d = document.createElement("div");
          d.className = "cell";
          d.id = `cell-${r}-${c}`;
          d.dataset.r = r; d.dataset.c = c;
          d.textContent = grid[r][c];
          gridEl.appendChild(d);
        }
      }
    }

    function renderLegend(words, placements, unplaced){
      // Fixed words per line using CSS Grid columns
      const cols = Math.max(1, Math.min(6, parseInt(wprInput.value || "3", 10)));
      legendEl.style.gridTemplateColumns = `repeat(${cols}, minmax(0, 1fr))`;
      legendEl.innerHTML = "";

      const idxByWord = new Map(words.map((w,i)=>[w,i]));
      for (const w of words){
        const isUnplaced = unplaced.includes(w);
        const isFound = current.foundWords.has(w);
        const row = document.createElement("div");
        row.className = "legend-item";
        const sw = document.createElement("span");
        sw.className = "swatch";
        sw.style.background = isUnplaced
            ? "transparent"
            : (isFound ? "#66ff9aff" : palette(idxByWord.get(w)).replace("88","ff"));
        sw.style.borderColor = isUnplaced ? "#2a3a75" : "rgba(0,0,0,.2)";
        const label = document.createElement("span");
        label.textContent = w;
        const mark = document.createElement("span");
        mark.className = isUnplaced ? "warn" : "ok";
        mark.textContent = isUnplaced ? "âš  not placed" : (isFound ? "âœ… found" : "âœ”");
        row.appendChild(sw); row.appendChild(label); row.appendChild(mark);
        legendEl.appendChild(row);
      }

      if (unplaced.length === 0){
        fitIndicator.textContent = "All words placed âœ”"; fitIndicator.className = "small ok";
      } else {
        fitIndicator.textContent = `${unplaced.length} didnâ€™t fit â€” increase size`; fitIndicator.className = "small warn";
      }
    }

    function applySolution(show){
      document.querySelectorAll(".cell").forEach(c=>{
        c.classList.remove("sol");
        if (!c.classList.contains("found")){
          c.style.background = "#0f1842"; c.style.color = "#eaf1ff";
        }
      });
      if (!show) return;
      const idxByWord = new Map(current.words.map((w,i)=>[w,i]));
      for (const [word,coords] of Object.entries(current.placements)){
        const idx = idxByWord.get(word) ?? 0;
        const color = palette(idx);
        for (const [r,c] of coords){
          const el = document.getElementById(`cell-${r}-${c}`);
          if (el && !el.classList.contains("found")){
            el.classList.add("sol");
            el.style.background = color; el.style.color = "#0d1330";
          }
        }
      }
    }

    /* ========= Drag selection ========= */
    let dragging = false, startCell = null, lastPath = [];

    const getCellFromEvent = (evt) => {
      const t = evt.target.closest?.(".cell");
      if (!t) return null;
      return { r: +t.dataset.r, c: +t.dataset.c, el: t };
    };
    const clampDir = dx => dx === 0 ? 0 : (dx > 0 ? 1 : -1);
    const isStraight = (r0,c0,r1,c1) =>
      (r0===r1) || (c0===c1) || (Math.abs(r1-r0)===Math.abs(c1-c0));
    function lineCoords(r0,c0,r1,c1){
      const steps = Math.max(Math.abs(r1-r0), Math.abs(c1-c0)) + 1;
      const dr = clampDir(r1-r0), dc = clampDir(c1-c0);
      const coords = []; for (let i=0;i<steps;i++) coords.push([r0+dr*i, c0+dc*i]);
      return coords;
    }
    function clearPreview(){
      lastPath.forEach(([r,c])=>{
        const el = document.getElementById(`cell-${r}-${c}`);
        if (!el) return;
        el.classList.remove("sel");
        if (!el.classList.contains("found") && !el.classList.contains("sol")){
          el.style.background = "#0f1842"; el.style.color = "#eaf1ff";
        }
      });
      lastPath = [];
    }
    function preview(r1,c1){
      if (!startCell) return;
      clearPreview();
      const {r:r0, c:c0} = startCell;
      if (!isStraight(r0,c0,r1,c1)) return;
      const coords = lineCoords(r0,c0,r1,c1);
      lastPath = coords;
      for (const [r,c] of coords){
        const el = document.getElementById(`cell-${r}-${c}`);
        if (el && !el.classList.contains("found")){
          el.classList.add("sel");
          el.style.background = "var(--select)"; el.style.color = "#07122e";
        }
      }
    }
    function commit(){
      if (lastPath.length===0) return;
      const forward = lastPath.map(([r,c])=> current.grid[r][c]).join("");
      const backward = [...forward].reverse().join("");
      const set = new Set(current.words);
      let matched = null;

      if (set.has(forward)) matched = forward;
      if (!matched && set.has(backward)) matched = backward;
      if (!matched){
        for (const w of current.words){
          const p = current.placements[w]; if (!p) continue;
          const a = JSON.stringify(p);
          const b = JSON.stringify(lastPath);
          const br = JSON.stringify([...lastPath].reverse());
          if (a===b || a===br){ matched = w; break; }
        }
      }
      if (matched && !current.unplaced.includes(matched)){
        current.foundWords.add(matched);
        for (const [r,c] of lastPath){
          const el = document.getElementById(`cell-${r}-${c}`);
          if (el){
            el.classList.remove("sel","sol");
            el.classList.add("found");
            el.style.background = "var(--found)";
            el.style.color = "#0b1b1d";
          }
        }
        renderLegend(current.words, current.placements, current.unplaced);
        const total = current.words.filter(w=>!current.unplaced.includes(w)).length;
        statusEl.textContent = (current.foundWords.size===total)
          ? "ðŸŽ‰ All words found!"
          : `Found: ${matched} (${current.foundWords.size}/${total})`;
      } else {
        clearPreview();
      }
    }

    function attachDragHandlers(){
      // Mouse
      gridEl.addEventListener("mousedown", (e)=>{
        const cell = getCellFromEvent(e); if (!cell) return;
        dragging = true; startCell = cell; preview(cell.r, cell.c); e.preventDefault();
      });
      gridEl.addEventListener("mousemove", (e)=>{
        if (!dragging) return; const cell = getCellFromEvent(e); if (!cell) return;
        preview(cell.r, cell.c);
      });
      window.addEventListener("mouseup", ()=>{
        if (!dragging) return; dragging = false; commit(); clearPreview(); startCell = null;
      });

      // Touch
      gridEl.addEventListener("touchstart", (e)=>{
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        const cellEl = el?.closest?.(".cell"); if (!cellEl) return;
        dragging = true; startCell = { r:+cellEl.dataset.r, c:+cellEl.dataset.c };
        preview(startCell.r, startCell.c); e.preventDefault();
      }, {passive:false});
      gridEl.addEventListener("touchmove", (e)=>{
        if (!dragging) return;
        const t = e.touches[0];
        const el = document.elementFromPoint(t.clientX, t.clientY);
        const cellEl = el?.closest?.(".cell"); if (!cellEl) return;
        preview(+cellEl.dataset.r, +cellEl.dataset.c); e.preventDefault();
      }, {passive:false});
      window.addEventListener("touchend", ()=>{
        if (!dragging) return; dragging = false; commit(); clearPreview(); startCell = null;
      });
    }

    /* ========= Controls ========= */
    function generate(){
      const words = readWordsStrict(); // strict: 1 word per line enforced
      const size = Math.max(8, Math.min(30, parseInt(document.getElementById("size").value || "12", 10)));
      if (words.length===0){ statusEl.textContent = "Add some words first (one per line)."; return; }

      const js = generateWordSearchJS(words, size);
      current.grid = js.grid; current.placements = js.placements;
      current.unplaced = js.unplaced; current.words = js.words;
      current.size = js.size; current.solutionShown = false; current.foundWords = new Set();

      renderGrid(current.grid, current.size);
      renderLegend(current.words, current.placements, current.unplaced);
      applySolution(false);

      document.getElementById("grid").style.gridTemplateColumns = `repeat(${current.size}, var(--cell))`;
      statusEl.textContent = `Made a ${current.size}Ã—${current.size} puzzle. ${Object.keys(current.placements).length} placed, ${current.unplaced.length} unplaced.`;
      toggleBtn.textContent = "Show solution";
    }
    function toggleSolution(){
      current.solutionShown = !current.solutionShown;
      applySolution(current.solutionShown);
      toggleBtn.textContent = current.solutionShown ? "Hide solution" : "Show solution";
    }

    document.getElementById("btn-generate").addEventListener("click", generate);
    document.getElementById("btn-toggle").addEventListener("click", toggleSolution);

    // Defaults
    document.getElementById("words").value = [
      "Bobby","Nani","Sagar","Swarna","Siva","Mani","Deepu","Akki","Sunny","Bindu","Honey","Rohit","Lakshmi"
    ].join("\n");
    const initialSize = parseInt(document.getElementById("size").value, 10) || 12;
    renderGrid(Array.from({length: initialSize}, ()=> " ".repeat(initialSize)), initialSize);
    attachDragHandlers();
  </script>
</body>
</html>
